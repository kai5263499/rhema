package main

import (
	"context"
	"time"

	"github.com/caarlos0/env"
	"github.com/gofrs/uuid"
	"github.com/sirupsen/logrus"

	. "github.com/kai5263499/rhema"

	"github.com/aws/aws-sdk-go/aws"
	"github.com/aws/aws-sdk-go/aws/credentials"
	"github.com/aws/aws-sdk-go/aws/session"
	"github.com/aws/aws-sdk-go/service/s3"

	"encoding/json"
	"net/http"

	pb "github.com/kai5263499/rhema/generated"

	"github.com/kai5263499/rhema/generated"

	_ "github.com/kai5263499/rhema/cmd/apiserver/docs" // docs is generated by Swag CLI, you have to import it.

	httpSwagger "github.com/swaggo/http-swagger"

	"github.com/gorilla/mux"

	"github.com/olivere/elastic/v7"

	firebase "firebase.google.com/go"
	"firebase.google.com/go/auth"
)

type config struct {
	LogLevel             string  `env:"LOG_LEVEL" envDefault:"debug"`
	AwsDefaultRegion     string  `env:"AWS_DEFAULT_REGION" envDefault:"us-east-1"`
	MinTextBlockSize     int     `env:"MIN_TEXT_BLOCK_SIZE" envDefault:"100"`
	S3Bucket             string  `env:"S3_BUCKET"`
	TmpPath              string  `env:"TMP_PATH" envDefault:"/tmp"`
	WordsPerMinute       int     `env:"WORDS_PER_MINUTE" envDefault:"350"`
	EspeakVoice          string  `env:"ESPEAK_VOICE" envDefault:"f5"`
	LocalPath            string  `env:"LOCAL_PATH" envDefault:"/data"`
	Atempo               float32 `env:"ATEMPO" envDefault:"2.0"`
	ChownTo              int     `env:"CHOWN_TO" envDefault:"1000"`
	TitleLengthLimit     int     `env:"TITLE_LENGTH_LIMIT" envDefault:"40"`
	ElasticSearchAddress string  `env:"ELASTICSEARCH_URL" envDefault:"http://localhost:9200"`
}

const (
	esIndex = "requests"
)

var (
	cfg              config
	contentProcessor *RequestProcessor
	esClient         *elastic.Client
	fbApp            *firebase.App
	fbAuth 			 *auth.Client
)

func checkError(msg string, err error) {
	if err != nil {
		logrus.WithError(err).Error(msg)
	}
}

// @title Rhema API
// @version 1.0
// @description This is a REST interface for the Rhema content to audio system
// @termsOfService http://swagger.io/terms/
// @contact.name Wes Widner
// @contact.email wes@manwe.io
// @license.name Apache 2.0
// @license.url http://www.apache.org/licenses/LICENSE-2.0.html
// @host localhost
// @BasePath /
func main() {
	cfg = config{}
	if err := env.Parse(&cfg); err != nil {
		checkError("parse config", err)
	}

	if level, err := logrus.ParseLevel(cfg.LogLevel); err != nil {
		checkError("parse log level", err)
	} else {
		logrus.SetLevel(level)
	}

	if app, err := firebase.NewApp(context.Background(), nil); err != nil {
		logrus.WithError(err).Fatalf("new firebase app")
	} else {
		fbApp = app
	}

	// Access auth service from the default app
	if client, err := fbApp.Auth(context.Background()); err != nil {
			logrus.WithError(err).Fatalf("new firebase auth")
	} else {
		fbAuth = client
	}

	s3svc := s3.New(session.New(aws.NewConfig().WithRegion(cfg.AwsDefaultRegion).WithCredentials(credentials.NewEnvCredentials())))

	var err1 error
	esClient, err1 = elastic.NewClient(elastic.SetURL(cfg.ElasticSearchAddress))
	checkError("new default elasticsearch client", err1)

	contentStorage := NewContentStorage(s3svc, cfg.TmpPath, cfg.S3Bucket, esClient)

	speedupAudo := NewSpeedupAudio(contentStorage, cfg.TmpPath, cfg.Atempo)

	scrape := NewScrape(contentStorage, uint32(cfg.MinTextBlockSize), cfg.TmpPath, cfg.TitleLengthLimit)
	text2mp3 := NewText2Mp3(contentStorage, cfg.TmpPath, cfg.WordsPerMinute, cfg.EspeakVoice)
	youtube := NewYoutube(scrape, contentStorage, speedupAudo, cfg.TmpPath)
	contentProcessor = NewRequestProcessor(cfg.TmpPath, scrape, youtube, text2mp3, speedupAudo, cfg.TitleLengthLimit)

	router := mux.NewRouter()
	router.HandleFunc("/request", createRequest).Methods("POST")
	router.HandleFunc("/request/{requestHash}", getRequest).Methods("GET")
	router.HandleFunc("/requests/{submittedBy}", getRequests).Methods("GET")

	router.PathPrefix("/swagger").Handler(httpSwagger.WrapHandler)

	logrus.Infof("serving")
	if err := http.ListenAndServe(":8080", router); err != nil {
		logrus.WithError(err).Fatalf("finished serving")
	}
}

// CreateRequest godoc
// @Summary Create a new content processing request
// @Description Create a new content to mp3 conversion request with the input paylod
// @Tags requests
// @Accept  json
// @Produce  json
// @Success 200 {object} generated.Request
// @Router /request [post]
func createRequest(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")
	var request generated.Request
	json.NewDecoder(r.Body).Decode(&request)

	newUUID := uuid.Must(uuid.NewV4())

	request.SubmittedAt = uint64(time.Now().UTC().Unix())

	if request.Created == 0 {
		request.Created = uint64(time.Now().UTC().Unix())
	}

	if request.RequestHash == "" {
		request.RequestHash = newUUID.String()
	}

	if request.Text != "" {
		request.Type = pb.Request_TEXT
		go contentProcessor.Process(request)
	} else if request.Uri != "" {
		request.Type = pb.Request_URI
		request.Title = newUUID.String()
		go contentProcessor.Process(request)
	} else {
		request.Text = "Invalid request. Uri or Text field must be provided."
	}

	json.NewEncoder(w).Encode(request)
}

// GetOrders godoc
// @Summary Get details of all requests
// @Description Get details of all requests
// @Tags requests
// @Accept  json
// @Produce  json
// @Success 200 {array} generated.Request
// @Router /requests/{submittedBy} [get]
func getRequests(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")

	params := mux.Vars(r)
	submittedBy := params["submittedBy"]

	logrus.WithFields(logrus.Fields{
		"SubmittedBy": submittedBy,
	}).Debugf("performing request")

	var request generated.Request
	var requests []generated.Request

	ctx := context.Background()
	termQuery := elastic.NewTermQuery("SubmittedBy", submittedBy)
	searchResult, _ := esClient.Search().
		Index(esIndex).
		Query(termQuery).
		From(0).Size(100).
		Do(ctx)

	logrus.Debugf("got %d hits", len(searchResult.Hits.Hits))

	for _, hit := range searchResult.Hits.Hits {
		json.Unmarshal(hit.Source, &request)
		requests = append(requests, request)
	}

	json.NewEncoder(w).Encode(requests)
}

// GetOrder godoc
// @Summary Get details for a given requestID
// @Description Get details of a content request for a given requestID
// @Tags requests
// @Accept  json
// @Produce  json
// @Param orderId path int true "ID of the order"
// @Success 200 {object} generated.Request
// @Router /request/{requestHash} [get]
func getRequest(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")

	params := mux.Vars(r)
	requestHash := params["requestHash"]

	logrus.WithFields(logrus.Fields{
		"RequestHash": requestHash,
	}).Debugf("performing request")

	ctx := context.Background()
	termQuery := elastic.NewTermQuery("RequestHash", requestHash)
	searchResult, _ := esClient.Search().
		Index(esIndex).
		Query(termQuery).
		From(0).Size(1).
		Do(ctx)

	logrus.Debugf("got %d hits", len(searchResult.Hits.Hits))

	hit := searchResult.Hits.Hits[0]

	var request pb.Request
	json.Unmarshal(hit.Source, &request)

	json.NewEncoder(w).Encode(request)
}
